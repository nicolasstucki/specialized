[[syntax trees at end of                     typer]] // newSource1
package <empty> {
  import scala.reflect.ClassTag;
  import ch.epfl.lamp.specialized._;
  class TestArray2Reverse[T >: Nothing <: Any] extends scala.AnyRef {
    implicit <paramaccessor> private[this] val classTag: scala.reflect.ClassTag[T] = _;
    def <init>()(implicit classTag: scala.reflect.ClassTag[T]): TestArray2Reverse[T] = {
      TestArray2Reverse.super.<init>();
      ()
    };
    private[this] val arr: Array[T] = TestArray2Reverse.this.classTag.newArray(2);
    <stable> <accessor> def arr: Array[T] = TestArray2Reverse.this.arr;
    def reverse: Unit = if (TestArray2Reverse.this.classTag.==(Predef.manifest[Int](ManifestFactory.Int)))
  TestArray2Reverse.this.spec[Int](TestArray2Reverse.this.arr.asInstanceOf[Array[Int]])
else
  if (TestArray2Reverse.this.classTag.==(Predef.manifest[Double](ManifestFactory.Double)))
    TestArray2Reverse.this.spec[Double](TestArray2Reverse.this.arr.asInstanceOf[Array[Double]])
  else
    if (TestArray2Reverse.this.classTag.==(Predef.manifest[Boolean](ManifestFactory.Boolean)))
      TestArray2Reverse.this.spec[Boolean](TestArray2Reverse.this.arr.asInstanceOf[Array[Boolean]])
    else
      TestArray2Reverse.this.spec[T](TestArray2Reverse.this.arr).asInstanceOf[Unit];
    def spec[@specialized U >: Nothing <: Any](arr: Array[U]): Unit = {
      val temp: U = arr.apply(0);
      arr.update(0, arr.apply(1));
      arr.update(1, temp)
    }
  }
}
