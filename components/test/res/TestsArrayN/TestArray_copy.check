[[syntax trees at end of                     typer]] // newSource1
package <empty> {
  import scala.reflect.ClassTag;
  import ch.epfl.lamp.specialized._;
  class TestArray[T >: Nothing <: Any] extends scala.AnyRef {
    <paramaccessor> private[this] val arrA: Array[T] = _;
    implicit <paramaccessor> private[this] val classTag: scala.reflect.ClassTag[T] = _;
    def <init>(arrA: Array[T])(implicit classTag: scala.reflect.ClassTag[T]): TestArray[T] = {
      TestArray.super.<init>();
      ()
    };
    private[this] val arrB: Array[T] = TestArray.this.classTag.newArray(TestArray.this.arrA.length);
    <stable> <accessor> def arrB: Array[T] = TestArray.this.arrB;
    private[this] val arrC: Array[T] = TestArray.this.classTag.newArray(TestArray.this.arrA.length);
    <stable> <accessor> def arrC: Array[T] = TestArray.this.arrC;
    def copy: Unit = {
      val arrB: Array[T] = this.arrB;
      val arrD: Array[T] = TestArray.this.classTag.newArray(TestArray.this.arrA.length);
      val arrE: Array[T] = TestArray.this.classTag.newArray(TestArray.this.arrA.length);
      {
        def copy_spec_Generic1(): Unit = scala.this.Predef.intWrapper(0).until(TestArray.this.arrA.length).foreach[Unit](((i: Int) => {
          arrB.update(i, TestArray.this.arrA.apply(i));
          arrD.update(i, TestArray.this.arrA.apply(i))
        }));
        def copy_spec_Boolean1(arrB: Array[Boolean], TestArray_this_arrA1: Array[Boolean], arrD: Array[Boolean]): Unit = scala.this.Predef.intWrapper(0).until(TestArray_this_arrA1.length).foreach[Unit](((i: Int) => {
          arrB.update(i, TestArray_this_arrA1.apply(i));
          arrD.update(i, TestArray_this_arrA1.apply(i))
        }));
        def copy_spec_Double1(arrB: Array[Double], TestArray_this_arrA1: Array[Double], arrD: Array[Double]): Unit = scala.this.Predef.intWrapper(0).until(TestArray_this_arrA1.length).foreach[Unit](((i: Int) => {
          arrB.update(i, TestArray_this_arrA1.apply(i));
          arrD.update(i, TestArray_this_arrA1.apply(i))
        }));
        def copy_spec_Int1(arrB: Array[Int], TestArray_this_arrA1: Array[Int], arrD: Array[Int]): Unit = scala.this.Predef.intWrapper(0).until(TestArray_this_arrA1.length).foreach[Unit](((i: Int) => {
          arrB.update(i, TestArray_this_arrA1.apply(i));
          arrD.update(i, TestArray_this_arrA1.apply(i))
        }));
        if (TestArray.this.classTag.==(ManifestFactory.Boolean))
  copy_spec_Boolean1(arrB.asInstanceOf[Array[Boolean]], TestArray.this.arrA.asInstanceOf[Array[Boolean]], arrD.asInstanceOf[Array[Boolean]])
else
  if (TestArray.this.classTag.==(ManifestFactory.Double))
    copy_spec_Double1(arrB.asInstanceOf[Array[Double]], TestArray.this.arrA.asInstanceOf[Array[Double]], arrD.asInstanceOf[Array[Double]])
  else
    if (TestArray.this.classTag.==(ManifestFactory.Int))
      copy_spec_Int1(arrB.asInstanceOf[Array[Int]], TestArray.this.arrA.asInstanceOf[Array[Int]], arrD.asInstanceOf[Array[Int]])
    else
      copy_spec_Generic1().asInstanceOf[Unit]
      }
    }
  }
}

[[syntax trees at end of                       jvm]] // newSource1
package <empty> {
  class TestArray extends Object {
    <paramaccessor> val TestArray$$arrA: Object = _;
    implicit <paramaccessor> private[this] val classTag: reflect.ClassTag = _;
    private[this] val arrB: Object = _;
    <stable> <accessor> def arrB(): Object = TestArray.this.arrB;
    private[this] val arrC: Object = _;
    <stable> <accessor> def arrC(): Object = TestArray.this.arrC;
    def copy(): Unit = {
      val arrB: Object = this.arrB();
      val arrD: Object = TestArray.this.classTag.newArray(runtime.this.ScalaRunTime.array_length(TestArray.this.TestArray$$arrA));
      val arrE: Object = TestArray.this.classTag.newArray(runtime.this.ScalaRunTime.array_length(TestArray.this.TestArray$$arrA));
      {
        {
          (if (TestArray.this.classTag.==(ManifestFactory.Boolean()))
            {
              TestArray.this.copy_spec_Boolean1$1(arrB.$asInstanceOf[Array[Boolean]](), TestArray.this.TestArray$$arrA.$asInstanceOf[Array[Boolean]](), arrD.$asInstanceOf[Array[Boolean]]());
              scala.runtime.BoxedUnit.UNIT
            }
          else
            if (TestArray.this.classTag.==(ManifestFactory.Double()))
              {
                TestArray.this.copy_spec_Double1$1(arrB.$asInstanceOf[Array[Double]](), TestArray.this.TestArray$$arrA.$asInstanceOf[Array[Double]](), arrD.$asInstanceOf[Array[Double]]());
                scala.runtime.BoxedUnit.UNIT
              }
            else
              if (TestArray.this.classTag.==(ManifestFactory.Int()))
                {
                  TestArray.this.copy_spec_Int1$1(arrB.$asInstanceOf[Array[Int]](), TestArray.this.TestArray$$arrA.$asInstanceOf[Array[Int]](), arrD.$asInstanceOf[Array[Int]]());
                  scala.runtime.BoxedUnit.UNIT
                }
              else
                {
                  TestArray.this.copy_spec_Generic1$1(arrB, arrD);
                  scala.runtime.BoxedUnit.UNIT
                }: runtime.BoxedUnit);
          ()
        }
      }
    };
    final private[this] def copy_spec_Generic1$1(arrB$1: Object, arrD$1: Object): Unit = RichInt.this.until$extension0(scala.this.Predef.intWrapper(0), runtime.this.ScalaRunTime.array_length(TestArray.this.TestArray$$arrA)).foreach$mVc$sp({
      (new anonymous class anonfun$copy_spec_Generic1$1$1(TestArray.this, arrB$1, arrD$1): Function1)
    });
    final private[this] def copy_spec_Boolean1$1(arrB: Array[Boolean], TestArray_this_arrA1: Array[Boolean], arrD: Array[Boolean]): Unit = RichInt.this.until$extension0(scala.this.Predef.intWrapper(0), TestArray_this_arrA1.length()).foreach$mVc$sp({
      (new anonymous class anonfun$copy_spec_Boolean1$1$1(TestArray.this, arrB, TestArray_this_arrA1, arrD): Function1)
    });
    final private[this] def copy_spec_Double1$1(arrB: Array[Double], TestArray_this_arrA1: Array[Double], arrD: Array[Double]): Unit = RichInt.this.until$extension0(scala.this.Predef.intWrapper(0), TestArray_this_arrA1.length()).foreach$mVc$sp({
      (new anonymous class anonfun$copy_spec_Double1$1$1(TestArray.this, arrB, TestArray_this_arrA1, arrD): Function1)
    });
    final private[this] def copy_spec_Int1$1(arrB: Array[Int], TestArray_this_arrA1: Array[Int], arrD: Array[Int]): Unit = RichInt.this.until$extension0(scala.this.Predef.intWrapper(0), TestArray_this_arrA1.length()).foreach$mVc$sp({
      (new anonymous class anonfun$copy_spec_Int1$1$1(TestArray.this, arrB, TestArray_this_arrA1, arrD): Function1)
    });
    def <init>(arrA: Object, classTag: reflect.ClassTag): TestArray = {
      TestArray.this.TestArray$$arrA = arrA;
      TestArray.this.classTag = classTag;
      TestArray.super.<init>();
      TestArray.this.arrB = classTag.newArray(runtime.this.ScalaRunTime.array_length(arrA));
      TestArray.this.arrC = classTag.newArray(runtime.this.ScalaRunTime.array_length(arrA));
      ()
    }
  };
  @SerialVersionUID(0) final <synthetic> class TestArray$$anonfun$copy_spec_Generic1$1$1 extends runtime.AbstractFunction1$mcVI$sp with Serializable {
    final def apply(i: Int): Unit = TestArray$$anonfun$copy_spec_Generic1$1$1.this.apply$mcVI$sp(i);
    <specialized> def apply$mcVI$sp(i: Int): Unit = {
      runtime.this.ScalaRunTime.array_update(TestArray$$anonfun$copy_spec_Generic1$1$1.this.arrB$1, i, runtime.this.ScalaRunTime.array_apply(TestArray$$anonfun$copy_spec_Generic1$1$1.this.$outer.TestArray$$arrA, i));
      runtime.this.ScalaRunTime.array_update(TestArray$$anonfun$copy_spec_Generic1$1$1.this.arrD$1, i, runtime.this.ScalaRunTime.array_apply(TestArray$$anonfun$copy_spec_Generic1$1$1.this.$outer.TestArray$$arrA, i))
    };
    <synthetic> <paramaccessor> private[this] val $outer: TestArray = _;
    final <bridge> def apply(v1: Object): Object = {
      TestArray$$anonfun$copy_spec_Generic1$1$1.this.apply(scala.Int.unbox(v1));
      scala.runtime.BoxedUnit.UNIT
    };
    <synthetic> <paramaccessor> private[this] val arrB$1: Object = _;
    <synthetic> <paramaccessor> private[this] val arrD$1: Object = _;
    def <init>($outer: TestArray, arrB$1: Object, arrD$1: Object): anonymous class anonfun$copy_spec_Generic1$1$1 = {
      if ($outer.eq(null))
        throw new NullPointerException()
      else
        TestArray$$anonfun$copy_spec_Generic1$1$1.this.$outer = $outer;
      TestArray$$anonfun$copy_spec_Generic1$1$1.this.arrB$1 = arrB$1;
      TestArray$$anonfun$copy_spec_Generic1$1$1.this.arrD$1 = arrD$1;
      TestArray$$anonfun$copy_spec_Generic1$1$1.super.<init>();
      ()
    }
  };
  @SerialVersionUID(0) final <synthetic> class TestArray$$anonfun$copy_spec_Boolean1$1$1 extends runtime.AbstractFunction1$mcVI$sp with Serializable {
    final def apply(i: Int): Unit = TestArray$$anonfun$copy_spec_Boolean1$1$1.this.apply$mcVI$sp(i);
    <specialized> def apply$mcVI$sp(i: Int): Unit = {
      TestArray$$anonfun$copy_spec_Boolean1$1$1.this.arrB$2.update(i, TestArray$$anonfun$copy_spec_Boolean1$1$1.this.TestArray_this_arrA1$1.apply(i));
      TestArray$$anonfun$copy_spec_Boolean1$1$1.this.arrD$2.update(i, TestArray$$anonfun$copy_spec_Boolean1$1$1.this.TestArray_this_arrA1$1.apply(i))
    };
    final <bridge> def apply(v1: Object): Object = {
      TestArray$$anonfun$copy_spec_Boolean1$1$1.this.apply(scala.Int.unbox(v1));
      scala.runtime.BoxedUnit.UNIT
    };
    <synthetic> <paramaccessor> private[this] val arrB$2: Array[Boolean] = _;
    <synthetic> <paramaccessor> private[this] val TestArray_this_arrA1$1: Array[Boolean] = _;
    <synthetic> <paramaccessor> private[this] val arrD$2: Array[Boolean] = _;
    def <init>($outer: TestArray, arrB$2: Array[Boolean], TestArray_this_arrA1$1: Array[Boolean], arrD$2: Array[Boolean]): anonymous class anonfun$copy_spec_Boolean1$1$1 = {
      TestArray$$anonfun$copy_spec_Boolean1$1$1.this.arrB$2 = arrB$2;
      TestArray$$anonfun$copy_spec_Boolean1$1$1.this.TestArray_this_arrA1$1 = TestArray_this_arrA1$1;
      TestArray$$anonfun$copy_spec_Boolean1$1$1.this.arrD$2 = arrD$2;
      TestArray$$anonfun$copy_spec_Boolean1$1$1.super.<init>();
      ()
    }
  };
  @SerialVersionUID(0) final <synthetic> class TestArray$$anonfun$copy_spec_Double1$1$1 extends runtime.AbstractFunction1$mcVI$sp with Serializable {
    final def apply(i: Int): Unit = TestArray$$anonfun$copy_spec_Double1$1$1.this.apply$mcVI$sp(i);
    <specialized> def apply$mcVI$sp(i: Int): Unit = {
      TestArray$$anonfun$copy_spec_Double1$1$1.this.arrB$3.update(i, TestArray$$anonfun$copy_spec_Double1$1$1.this.TestArray_this_arrA1$2.apply(i));
      TestArray$$anonfun$copy_spec_Double1$1$1.this.arrD$3.update(i, TestArray$$anonfun$copy_spec_Double1$1$1.this.TestArray_this_arrA1$2.apply(i))
    };
    final <bridge> def apply(v1: Object): Object = {
      TestArray$$anonfun$copy_spec_Double1$1$1.this.apply(scala.Int.unbox(v1));
      scala.runtime.BoxedUnit.UNIT
    };
    <synthetic> <paramaccessor> private[this] val arrB$3: Array[Double] = _;
    <synthetic> <paramaccessor> private[this] val TestArray_this_arrA1$2: Array[Double] = _;
    <synthetic> <paramaccessor> private[this] val arrD$3: Array[Double] = _;
    def <init>($outer: TestArray, arrB$3: Array[Double], TestArray_this_arrA1$2: Array[Double], arrD$3: Array[Double]): anonymous class anonfun$copy_spec_Double1$1$1 = {
      TestArray$$anonfun$copy_spec_Double1$1$1.this.arrB$3 = arrB$3;
      TestArray$$anonfun$copy_spec_Double1$1$1.this.TestArray_this_arrA1$2 = TestArray_this_arrA1$2;
      TestArray$$anonfun$copy_spec_Double1$1$1.this.arrD$3 = arrD$3;
      TestArray$$anonfun$copy_spec_Double1$1$1.super.<init>();
      ()
    }
  };
  @SerialVersionUID(0) final <synthetic> class TestArray$$anonfun$copy_spec_Int1$1$1 extends runtime.AbstractFunction1$mcVI$sp with Serializable {
    final def apply(i: Int): Unit = TestArray$$anonfun$copy_spec_Int1$1$1.this.apply$mcVI$sp(i);
    <specialized> def apply$mcVI$sp(i: Int): Unit = {
      TestArray$$anonfun$copy_spec_Int1$1$1.this.arrB$4.update(i, TestArray$$anonfun$copy_spec_Int1$1$1.this.TestArray_this_arrA1$3.apply(i));
      TestArray$$anonfun$copy_spec_Int1$1$1.this.arrD$4.update(i, TestArray$$anonfun$copy_spec_Int1$1$1.this.TestArray_this_arrA1$3.apply(i))
    };
    final <bridge> def apply(v1: Object): Object = {
      TestArray$$anonfun$copy_spec_Int1$1$1.this.apply(scala.Int.unbox(v1));
      scala.runtime.BoxedUnit.UNIT
    };
    <synthetic> <paramaccessor> private[this] val arrB$4: Array[Int] = _;
    <synthetic> <paramaccessor> private[this] val TestArray_this_arrA1$3: Array[Int] = _;
    <synthetic> <paramaccessor> private[this] val arrD$4: Array[Int] = _;
    def <init>($outer: TestArray, arrB$4: Array[Int], TestArray_this_arrA1$3: Array[Int], arrD$4: Array[Int]): anonymous class anonfun$copy_spec_Int1$1$1 = {
      TestArray$$anonfun$copy_spec_Int1$1$1.this.arrB$4 = arrB$4;
      TestArray$$anonfun$copy_spec_Int1$1$1.this.TestArray_this_arrA1$3 = TestArray_this_arrA1$3;
      TestArray$$anonfun$copy_spec_Int1$1$1.this.arrD$4 = arrD$4;
      TestArray$$anonfun$copy_spec_Int1$1$1.super.<init>();
      ()
    }
  }
}